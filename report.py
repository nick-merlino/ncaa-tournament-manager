"""
report.py

Generates a comprehensive PDF report for the NCAA Tournament application.
The report includes:
  - A current round overview with player picks and score breakdown.
  - A "Locked Positions" section near the top, which also displays any tie of up to 3 players
    for 1st, 2nd, 3rd, or Last.
  - Visuals including:
      * 10 Most Popular Teams Chart
      * 10 Least Popular Teams Chart
      * Player Points Line Chart
      * Upsets Table
      * Best Case Scenario Final Scores Table

Each visual is generated by its own function.
"""

import json
from io import BytesIO
from datetime import datetime

import pandas as pd
import plotly.graph_objects as go
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Image, PageBreak,
    HRFlowable, KeepTogether, Table, TableStyle
)
from reportlab.lib.pagesizes import LETTER
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet

from config import logger
from db import SessionLocal, User, UserPick, UserScore, TournamentResult
from constants import ROUND_ORDER, ROUND_WEIGHTS, FIRST_ROUND_PAIRINGS
from scoring import (
    get_round_game_status,
    calculate_best_case_scores,
    calculate_worst_case_scores,
    calculate_maximum_possible_score
)


def fig_to_image(fig):
    """
    Converts a Plotly figure to a PNG image in memory.
    """
    try:
        return fig.to_image(format="png")
    except Exception as e:
        logger.error(f"Error converting figure to image: {e}")
        return None


def add_page_number(canvas, doc):
    """
    Adds a page number to the PDF canvas at the bottom center.
    """
    page_num = canvas.getPageNumber()
    text = f"Page {page_num}"
    canvas.setFont("Helvetica", 8)
    canvas.drawCentredString(LETTER[0] / 2, 20, text)


def determine_team_status(team, current_round, round_games):
    """
    Determines the status of a team for the current round.

    Returns:
      - 'out': if the team lost in any fully completed round, or if a game
               in the current round has been played and the team did not win.
      - 'won': if the team won in the current round (and that game is decided).
      - 'not_played': if the team is still alive (no deciding game result yet).
    """
    if current_round not in ROUND_ORDER:
        return "not_played"

    current_index = ROUND_ORDER.index(current_round)

    # Check earlier rounds (fully completed).
    for i in range(current_index):
        rnd = ROUND_ORDER[i]
        if rnd in round_games:
            for game in round_games[rnd]:
                if game.get("winner") and game["winner"].strip() != team.strip():
                    if team.strip() in (game["team1"].strip(), game["team2"].strip()):
                        return "out"

    # Check the current round's partial completeness
    if current_round in round_games:
        for game in round_games[current_round]:
            if game.get("winner") and game["winner"].strip():
                if team.strip() == game["winner"].strip():
                    return "won"
                elif team.strip() in (game["team1"].strip(), game["team2"].strip()):
                    return "out"

    return "not_played"


def generate_header(story, styles, current_round):
    """
    Renders a title header for the PDF.
    """
    year = datetime.now().year
    story.append(Paragraph(f"Merlino NCAA March Madness {year}", styles['Title']))


def generate_user_overview(story, styles, df, user_points_df, sorted_users, visible_rounds, current_round):
    """
    Generates a section showing each player's picks and points, grouped by
    whether the pick is 'won this round', 'not played yet', or 'out'.
    """
    max_score = calculate_maximum_possible_score()

    story.append(HRFlowable(width="100%", thickness=1, color=colors.black))

    story.append(Paragraph(
        f'<para align="center"><b>Current Round in Progress: {current_round}</b></para>',
        styles['Heading2']
    ))
    story.append(Paragraph(
        '<para align="center"><font size="8" color="grey">Team Key: "Seed-Team Name (Points)"</font></para>',
        styles['Normal']
    ))
    story.append(Paragraph(
        f'<para align="center"><font size="8" color="grey">Maximum Theoretical Score: {max_score}</font></para>',
        styles['Normal']
    ))
    story.append(Spacer(1, 12))

    story.append(HRFlowable(width="100%", thickness=1, color=colors.black))
    story.append(Spacer(1, 6))

    previous_points = None
    for uname in sorted_users:
        if not df.empty and not user_points_df.empty:
            if uname in user_points_df['username'].values:
                user_pts = user_points_df.loc[user_points_df['username'] == uname, 'points'].values[0]
            else:
                user_pts = 0.0
        else:
            user_pts = 0.0

        # Visual separator if points differ from previous
        if previous_points is not None and user_pts != previous_points:
            story.append(HRFlowable(width="100%", thickness=1, color=colors.black))
            story.append(Spacer(1, 6))

        header_line = f"{uname} - <b>Points:</b> {user_pts:.0f}"
        player_flowables = [Paragraph(header_line, styles['Heading3'])]

        still_in_picks = []
        not_played_picks = []
        out_picks = []

        # Subset for user picks
        user_rows = df[df['username'] == uname]
        for _, row in user_rows.iterrows():
            team = row['team_name']
            seed_label = row['seed_label']
            try:
                seed_int = int(seed_label.replace("Seed", "").strip())
            except ValueError:
                seed_int = 999

            status = determine_team_status(team, current_round, visible_rounds)

            # Tally how many points so far for that pick
            pick_points = 0
            for rnd in ROUND_ORDER:
                if rnd in visible_rounds:
                    for game in visible_rounds[rnd]:
                        if game.get('winner') and game['winner'].strip() == team.strip():
                            pick_points += ROUND_WEIGHTS.get(rnd, 1)
                            break

            label_str = f"{seed_int}-{team} ({pick_points})"
            if status == 'won':
                still_in_picks.append((seed_int, label_str))
            elif status == 'out':
                out_picks.append((seed_int, label_str))
            else:
                not_played_picks.append((seed_int, label_str))

        # Sort picks by seed
        still_in_list = [p[1] for p in sorted(still_in_picks, key=lambda x: x[0])]
        not_played_list = [p[1] for p in sorted(not_played_picks, key=lambda x: x[0])]
        out_list = [p[1] for p in sorted(out_picks, key=lambda x: x[0])]

        def format_category(cat, items):
            if items:
                return f"<b>{cat} ({len(items)}):</b> " + ", ".join(items)
            else:
                return f"<b>{cat}:</b> None"

        player_flowables.append(Paragraph(format_category("Won This Round", still_in_list), styles['Normal']))
        player_flowables.append(Paragraph(format_category("Not Played Yet", not_played_list), styles['Normal']))
        player_flowables.append(Paragraph(format_category("Out", out_list), styles['Normal']))

        story.append(KeepTogether(player_flowables))
        story.append(Spacer(1, 12))
        previous_points = user_pts

    story.append(HRFlowable(width="100%", thickness=1, color=colors.black))

def generate_locked_positions_section(
    story, styles,
    user_points_df,
    sorted_users,
    best_case_scores,
    worst_case_scores
):
    """
    Displays locked positions for 1st, 2nd, 3rd, and Last, using the definition:
      - "A user is locked for that position if their worstCase >= every other
         user's bestCase among the remaining group for that position."

    For 'Last', we do the analogous approach in reverse:
      - "A user is locked for last if their bestCase <= every other remaining user's worstCase."

    Output format (centered, with bold rank labels):
      <para align='center'><b>Winners</b></para>
      <para align='center'><b>1st</b> - NameX / NameY</para>
      <para align='center'><b>2nd</b> - ...</para>
      <para align='center'><b>3rd</b> - </para>
      <para align='center'><b>Last</b> - NameZ</para>
    """

    from reportlab.platypus import Paragraph, Spacer
    from reportlab.lib import colors

    # Centered heading
    story.append(Paragraph("<para align='center'><b>Winners</b></para>", styles['Heading2']))

    if user_points_df.empty or user_points_df.shape[0] == 0:
        # If no scores exist
        story.append(Paragraph("<para align='center'>No scores available.</para>", styles['Normal']))
        story.append(Spacer(1, 12))
        return

    # Quick lookups
    current_scores = {row['username']: row['points'] for _, row in user_points_df.iterrows()}

    # Separate user lists for top/bottom rank logic
    remaining_for_top = sorted_users[:]
    remaining_for_bottom = sorted_users[:]

    def is_locked_for_position(u, group):
        u_wc = worst_case_scores.get(u, current_scores[u])
        for other in group:
            if other == u:
                continue
            o_bc = best_case_scores.get(other, current_scores[other])
            if o_bc > u_wc:
                return False
        return True

    def is_locked_for_last(u, group):
        u_bc = best_case_scores.get(u, current_scores[u])
        for other in group:
            if other == u:
                continue
            o_wc = worst_case_scores.get(other, current_scores[other])
            if o_wc < u_bc:
                return False
        return True

    def lock_next_rank(rem):
        locked = []
        for u in rem:
            if is_locked_for_position(u, rem):
                locked.append(u)
        return locked

    def lock_next_last(rem):
        locked = []
        for u in rem:
            if is_locked_for_last(u, rem):
                locked.append(u)
        return locked

    # Lock sets
    locked_1st = set()
    locked_2nd = set()
    locked_3rd = set()

    # 1) 1st
    cand_1st = lock_next_rank(remaining_for_top)
    if cand_1st:
        locked_1st.update(cand_1st)
        remaining_for_top = [u for u in remaining_for_top if u not in locked_1st]

    # 2) 2nd
    cand_2nd = lock_next_rank(remaining_for_top)
    if cand_2nd:
        locked_2nd.update(cand_2nd)
        remaining_for_top = [u for u in remaining_for_top if u not in locked_2nd]

    # 3) 3rd
    cand_3rd = lock_next_rank(remaining_for_top)
    if cand_3rd:
        locked_3rd.update(cand_3rd)
        remaining_for_top = [u for u in remaining_for_top if u not in locked_3rd]

    # Last
    locked_last = set()
    cand_last = lock_next_last(remaining_for_bottom)
    if cand_last:
        locked_last.update(cand_last)
        remaining_for_bottom = [u for u in remaining_for_bottom if u not in locked_last]

    # Format line: e.g. "<para align='center'><b>1st</b> - Name1 / Name2</para>"
    def format_line(label, user_set):
        if not user_set:
            return f"<para align='center'><b>{label}</b> - TBD</para>"
        names = sorted(user_set)
        joined = " / ".join(names)
        return f"<para align='center'><b>{label}</b> - {joined}</para>"

    lines = [
        format_line("1st", locked_1st),
        format_line("2nd", locked_2nd),
        format_line("3rd", locked_3rd),
        format_line("Last", locked_last),
    ]

    for ln in lines:
        story.append(Paragraph(ln, styles['Normal']))

    story.append(Spacer(1, 12))

def generate_popularity_charts(story, styles, df, visible_rounds):
    """
    Generates two charts (most and least popular teams) stacked vertically, 
    forcing them onto the same page if possible.
    """
    import pandas as pd
    import json
    import plotly.graph_objects as go
    from io import BytesIO
    from reportlab.platypus import Paragraph, Spacer, KeepTogether, Image
    from reportlab.lib import colors
    from config import logger  # or wherever you keep 'logger'
    from db import SessionLocal, TournamentResult
    from constants import ROUND_ORDER

    # 1) A local function for converting a Plotly figure to a PNG in memory:
    def fig_to_image_local(fig):
        try:
            return fig.to_image(format="png")
        except Exception as e:
            logger.error(f"Error converting figure to image: {e}")
            return None

    # We'll collect the chart flowables in this list, then wrap them in KeepTogether
    flowables = []

    # ---------------------------------------------------------
    # Most Popular Teams
    # ---------------------------------------------------------
    session = SessionLocal()
    try:
        first_round_games = session.query(TournamentResult).filter(
            TournamentResult.round_name.like("Round of 64%")
        ).all()
        bracket_teams = {g.team1.strip() for g in first_round_games}.union(
                        {g.team2.strip() for g in first_round_games})
        remaining = set(bracket_teams)

        # Eliminate teams that have definitively lost
        for round_name in ROUND_ORDER:
            if round_name in visible_rounds:
                games = visible_rounds[round_name]
                if all(g.get('winner') for g in games):
                    # If all decided, remove losers
                    for gm in games:
                        losers = {gm['team1'].strip(), gm['team2'].strip()} - {gm['winner'].strip()}
                        remaining -= losers
                else:
                    # Partial, remove only known losers
                    for gm in games:
                        if gm.get('winner'):
                            losers = {gm['team1'].strip(), gm['team2'].strip()} - {gm['winner'].strip()}
                            remaining -= losers
                    break

        teams_df = pd.DataFrame({'team_name': list(bracket_teams)})
        teams_df = teams_df[teams_df['team_name'].isin(remaining)]

        pick_counts = df.groupby('team_name')['username'].nunique().reset_index().rename(
            columns={'username': 'pick_count'}
        )
        teams_df = teams_df.merge(pick_counts, on='team_name', how='left')
        teams_df['pick_count'] = teams_df['pick_count'].fillna(0).astype(int)

        # Load seeds from bracket JSON
        with open("tournament_bracket.json", "r") as f:
            bracket_info = json.load(f)
        team_seeds = {
            t["team_name"].strip(): t["seed"]
            for region in bracket_info.get("regions", [])
            for t in region.get("teams", [])
        }

        teams_df["x_label"] = teams_df["team_name"].apply(
            lambda tn: f"({team_seeds.get(tn, 'N/A')}) {tn}"
        )

        top_remaining = teams_df.sort_values(by=['pick_count', 'team_name'], ascending=[False, True]).head(10)
        fig_top = go.Figure(
            data=[go.Bar(x=top_remaining["x_label"], y=top_remaining['pick_count'])],
            layout=dict(template="plotly_white")
        )
        fig_top.update_layout(xaxis_title="Team", yaxis_title="Number of Picks", title="")

        top_img = fig_to_image_local(fig_top)

        top_title = Paragraph(
            '<para align="center"><b>10 Most Popular Teams Still Remaining</b></para>',
            styles['Heading2']
        )
        flowables.append(top_title)
        if top_img:
            flowables.append(Image(BytesIO(top_img), width=450, height=300))

    except Exception as e:
        logger.error(f"Error generating most popular chart: {e}")
    finally:
        session.close()

    # ---------------------------------------------------------
    # Least Popular Teams
    # ---------------------------------------------------------
    session = SessionLocal()
    try:
        first_round_games = session.query(TournamentResult).filter(
            TournamentResult.round_name.like("Round of 64%")
        ).all()
        bracket_teams = {g.team1.strip() for g in first_round_games}.union(
                        {g.team2.strip() for g in first_round_games})
        remaining = set(bracket_teams)

        for round_name in ROUND_ORDER:
            if round_name in visible_rounds:
                games = visible_rounds[round_name]
                if all(g.get('winner') for g in games):
                    for gm in games:
                        losers = {gm['team1'].strip(), gm['team2'].strip()} - {gm['winner'].strip()}
                        remaining -= losers
                else:
                    for gm in games:
                        if gm.get('winner'):
                            losers = {gm['team1'].strip(), gm['team2'].strip()} - {gm['winner'].strip()}
                            remaining -= losers
                    break

        teams_df = pd.DataFrame({'team_name': list(bracket_teams)})
        teams_df = teams_df[teams_df['team_name'].isin(remaining)]

        pick_counts = df.groupby('team_name')['username'].nunique().reset_index().rename(
            columns={'username': 'pick_count'}
        )
        teams_df = teams_df.merge(pick_counts, on='team_name', how='left')
        teams_df['pick_count'] = teams_df['pick_count'].fillna(0).astype(int)

        with open("tournament_bracket.json", "r") as f:
            bracket_info = json.load(f)
        team_seeds = {
            t["team_name"].strip(): t["seed"]
            for region in bracket_info.get("regions", [])
            for t in region.get("teams", [])
        }

        teams_df["x_label"] = teams_df["team_name"].apply(
            lambda tn: f"({team_seeds.get(tn, 'N/A')}) {tn}"
        )

        least_remaining = teams_df.sort_values(by=['pick_count', 'team_name'], ascending=[True, True]).head(10)
        fig_least = go.Figure(
            data=[go.Bar(x=least_remaining["x_label"], y=least_remaining['pick_count'])],
            layout=dict(template="plotly_white")
        )
        fig_least.update_layout(xaxis_title="Team", yaxis_title="Number of Picks", title="")

        least_img = fig_to_image_local(fig_least)

        least_title = Paragraph(
            '<para align="center"><b>10 Least Popular Teams Still Remaining</b></para>',
            styles['Heading2']
        )
        flowables.append(least_title)
        if least_img:
            flowables.append(Image(BytesIO(least_img), width=450, height=300))
    except Exception as e:
        logger.error(f"Error generating least popular chart: {e}")
    finally:
        session.close()

    # ---------------------------------------------------------
    # Wrap everything in KeepTogether so they won't split across pages
    # ---------------------------------------------------------
    story.append(KeepTogether(flowables))

def generate_player_points_chart(story, styles, user_points_df):
    """
    Generates a line chart showing player points, sorted descending by points.
    """
    try:
        if not user_points_df.empty:
            user_points_sorted = user_points_df.sort_values(by='points', ascending=False)
            x_vals = user_points_sorted['username'].tolist()

            fig_line = go.Figure(
                data=[go.Scatter(x=x_vals, y=user_points_sorted['points'], mode="lines+markers")],
                layout=dict(template="plotly_white")
            )
            fig_line.update_layout(
                xaxis_title="Player",
                yaxis_title="Points",
                title="",
                xaxis_tickangle=-45,
                width=800,
                margin=dict(l=40, r=40, t=40, b=150),
                xaxis=dict(tickfont=dict(size=10))
            )
            line_img = fig_to_image(fig_line)

            line_title = Paragraph('<para align="center"><b>Player Points</b></para>', styles['Heading2'])
            group = [line_title]
            if line_img:
                group.append(Image(BytesIO(line_img), width=500, height=300))
            story.append(PageBreak())
            story.append(KeepTogether(group))

    except Exception as e:
        logger.error(f"Error generating player points chart: {e}")


def generate_upsets_table(story, styles):
    """
    Generates a table of games with the biggest upsets (based on seed differential).
    """
    try:
        with open("tournament_bracket.json", 'r') as f:
            bracket_info = json.load(f)
        team_seeds = {}
        for region in bracket_info.get("regions", []):
            for team in region.get("teams", []):
                if "team_name" in team and team["team_name"]:
                    team_seeds[team["team_name"].strip()] = team.get("seed", 999)

        upsets = []
        session = SessionLocal()
        try:
            decided = session.query(TournamentResult).filter(TournamentResult.winner.isnot(None)).all()
            for game in decided:
                if game.winner:
                    team1_seed = team_seeds.get(game.team1.strip(), 999)
                    team2_seed = team_seeds.get(game.team2.strip(), 999)
                    if game.winner.strip() == game.team1.strip():
                        winner_seed = team1_seed
                        loser_seed = team2_seed
                    else:
                        winner_seed = team2_seed
                        loser_seed = team1_seed
                    if winner_seed > loser_seed:
                        diff = winner_seed - loser_seed
                        upsets.append({
                            'round': game.round_name,
                            'winner': f"({winner_seed}) {game.winner}",
                            'loser': f"({loser_seed}) " + (
                                game.team1 if game.winner.strip() == game.team2.strip() else game.team2
                            ),
                            'differential': diff
                        })
        finally:
            session.close()

        if upsets:
            upset_data = [['Round', 'Winner', 'Loser', 'Seed Differential']]
            for up in sorted(upsets, key=lambda x: x['differential'], reverse=True):
                upset_data.append([up['round'], up['winner'], up['loser'], up['differential']])
            upset_table = Table(upset_data)
            upset_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
        else:
            upset_table = None

        upset_title = Paragraph('<para align="center"><b>Games with Biggest Upsets</b></para>', styles['Heading2'])
        group = [upset_title]
        if upset_table:
            group.append(upset_table)
        else:
            group.append(Paragraph("<para align='center'>No upsets recorded yet.</para>", styles['Normal']))
        story.append(KeepTogether(group))
        story.append(Spacer(1, 12))

    except Exception as e:
        logger.error(f"Error generating upsets table: {e}")


def generate_potential_score_table(story, styles, user_points_df, sorted_users):
    """
    Generates a table showing, for each user:
      - Rank
      - Player
      - Current Score
      - Guaranteed
      - Potential
      - Worst Case Score
      - Best Case Score

    Guaranteed Points = (Worst Case Score - Current Score)
    Potential Points  = (Best Case Score - Current Score)

    The table is sorted by best-case score descending, then current, then guaranteed, then potential, then name.
    """
    try:
        best_case_scores = calculate_best_case_scores()
        worst_case_scores = calculate_worst_case_scores()

        # Build dict of current scores
        current_scores = {}
        if not user_points_df.empty:
            for _, row in user_points_df.iterrows():
                current_scores[row['username']] = row['points']
        else:
            for uname in sorted_users:
                current_scores[uname] = 0

        potential_points = {}
        guaranteed_points = {}
        for uname in sorted_users:
            bc = best_case_scores.get(uname, current_scores[uname])
            wc = worst_case_scores.get(uname, current_scores[uname])
            cur = current_scores[uname]
            potential_points[uname] = bc - cur
            guaranteed_points[uname] = wc - cur

        # Sort primarily by best-case desc, then current desc, then guaranteed desc, then potential desc, then name
        sorted_players = sorted(
            sorted_users,
            key=lambda x: (
                -best_case_scores.get(x, current_scores[x]),
                -current_scores[x],
                -guaranteed_points[x],
                -potential_points[x],
                x
            )
        )

        # Build rank logic
        ranked_list = []
        prev_best = None
        current_rank = 0
        for idx, uname in enumerate(sorted_players, start=1):
            bc = best_case_scores.get(uname, current_scores[uname])
            wc = worst_case_scores.get(uname, current_scores[uname])
            cur = current_scores[uname]
            guar = guaranteed_points[uname]
            pot = potential_points[uname]

            if bc != prev_best:
                current_rank = idx

            ranked_list.append((current_rank, uname, cur, guar, pot, wc, bc))
            prev_best = bc

        header = [
            'Rank',
            'Player',
            'Current Score',
            'Guaranteed',
            'Potential',
            'Worst Case Score',
            'Best Case Score'
        ]
        table_data = [header]
        for row in ranked_list:
            rank, uname, cur, guar, pot, wc, bc = row
            table_data.append([
                str(rank),
                uname,
                f"{cur:.0f}",
                f"{guar:.0f}",
                f"{pot:.0f}",
                f"{wc:.0f}",
                f"{bc:.0f}"
            ])
        table_data.append(header)  # repeated header at bottom

        # We'll span vertically any identical rank cells
        span_commands = []
        row_idx = 1
        while row_idx < len(table_data) - 1:
            current_value = table_data[row_idx][0]  # rank
            start_idx = row_idx
            end_idx = row_idx
            while end_idx + 1 < len(table_data) - 1 and table_data[end_idx + 1][0] == current_value:
                end_idx += 1
            if end_idx > start_idx:
                span_commands.append(("SPAN", (0, start_idx), (0, end_idx)))
            row_idx = end_idx + 1

        potential_table = Table(table_data, hAlign='CENTER')
        base_style = [
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 10),
            ('BACKGROUND', (0, len(table_data) - 1), (-1, len(table_data) - 1), colors.grey),
            ('TEXTCOLOR', (0, len(table_data) - 1), (-1, len(table_data) - 1), colors.whitesmoke),
            ('FONTNAME', (0, len(table_data) - 1), (-1, len(table_data) - 1), 'Helvetica-Bold'),
            ('BOTTOMPADDING', (0, len(table_data) - 1), (-1, len(table_data) - 1), 10),
        ]
        base_style.extend(span_commands)
        potential_table.setStyle(TableStyle(base_style))

        story.append(PageBreak())
        story.append(Paragraph('<para align="center"><b>Potential Score Scenarios</b></para>', styles['Heading2']))
        story.append(potential_table)
    except Exception as e:
        logger.error(f"Error generating potential score table: {e}")


def generate_report(pdf_path, pdf_filename):
    """
    Generates the comprehensive PDF report with all sections.
    Includes the locked positions section near the top, as well as best/worst-case
    calculations and other charts/tables.
    """

    doc = SimpleDocTemplate(pdf_path, pagesize=LETTER,
                            leftMargin=36, rightMargin=36,
                            topMargin=36, bottomMargin=36, title=pdf_filename)
    styles = getSampleStyleSheet()
    story = []

    session = SessionLocal()
    try:
        # --------------------------------------------------
        # 1) Gather user picks and scores from the database
        # --------------------------------------------------
        all_users = session.query(User).all()

        user_data = []
        for u in all_users:
            for p in u.picks:
                user_data.append({
                    'username': u.full_name,
                    'seed_label': p.seed_label,
                    'team_name': p.team_name
                })
        df = pd.DataFrame(user_data, columns=['username', 'seed_label', 'team_name'])

        # Scores table
        scores = session.query(UserScore).all()
        points_data = []
        for s in scores:
            user_obj = session.query(User).filter_by(user_id=s.user_id).first()
            if user_obj:
                points_data.append({
                    'username': user_obj.full_name,
                    'points': s.points
                })
        user_points_df = pd.DataFrame(points_data, columns=['username', 'points'])

        # Sort users by points desc, then name asc
        if not user_points_df.empty:
            user_points_df = user_points_df.sort_values(by=['points', 'username'], ascending=[False, True])
            sorted_users = user_points_df['username'].tolist()
        else:
            sorted_users = sorted(df['username'].unique())

        # --------------------------------------------------
        # 2) Determine which rounds are visible/current
        # --------------------------------------------------
        current_round, visible_rounds = get_round_game_status()
        if not current_round:
            current_round = ROUND_ORDER[0]

        # --------------------------------------------------
        # 3) Compute best/worst case scenarios
        # --------------------------------------------------
        best_case_scores = calculate_best_case_scores()
        worst_case_scores = calculate_worst_case_scores()

        # --------------------------------------------------
        # 4) Build the PDF sections
        # --------------------------------------------------

        # 4a) Header
        generate_header(story, styles, current_round)

        # 4b) Locked Positions (with tie listing)
        generate_locked_positions_section(
            story,
            styles,
            user_points_df,
            sorted_users,
            best_case_scores,
            worst_case_scores
        )
        # 4c) Current Round Overview
        generate_user_overview(story, styles, df, user_points_df, sorted_users, visible_rounds, current_round)

        # 4d) Charts/Tables
        generate_popularity_charts(story, styles, df, visible_rounds)
        generate_player_points_chart(story, styles, user_points_df)
        generate_upsets_table(story, styles)
        generate_potential_score_table(story, styles, user_points_df, sorted_users)

    except Exception as e:
        logger.error(f"Error generating report: {e}")
    finally:
        session.close()

    def on_page(canvas, doc):
        add_page_number(canvas, doc)

    doc.build(story, onFirstPage=on_page, onLaterPages=on_page)
    logger.info(f"PDF report generated: {pdf_path}")
